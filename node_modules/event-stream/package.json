{
  "_from": "event-stream@>=3.3.0 <3.4.0",
  "_id": "event-stream@3.3.4",
  "_location": "/event-stream",
  "_nodeVersion": "6.2.0",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/event-stream-3.3.4.tgz_1468740248120_0.7839670591056347"
  },
  "_npmUser": {
    "name": "dominictarr",
    "email": "dominic.tarr@gmail.com"
  },
  "_npmVersion": "3.8.9",
  "_phantomChildren": {},
  "_requiredBy": [
    "/ps-tree"
  ],
  "_resolved": "https://registry.npmjs.org/event-stream/-/event-stream-3.3.4.tgz",
  "_shasum": "4ab4c9a0f5a54db9338b4c34d86bfce8f4b35571",
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://bit.ly/dominictarr"
  },
  "bugs": {
    "url": "https://github.com/dominictarr/event-stream/issues"
  },
  "dependencies": {
    "duplexer": "~0.1.1",
    "from": "~0",
    "map-stream": "~0.1.0",
    "pause-stream": "0.0.11",
    "split": "0.3",
    "stream-combiner": "~0.0.4",
    "through": "~2.3.1"
  },
  "description": "construct pipes of streams of events",
  "devDependencies": {
    "asynct": "*",
    "it-is": "1",
    "stream-spec": "~0.3.5",
    "tape": "~2.3.0",
    "ubelt": "~3.2.2"
  },
  "directories": {},
  "dist": {
    "shasum": "4ab4c9a0f5a54db9338b4c34d86bfce8f4b35571",
    "tarball": "https://registry.npmjs.org/event-stream/-/event-stream-3.3.4.tgz"
  },
  "gitHead": "0d9d45744b06ead81976b3400569160b76299a41",
  "homepage": "http://github.com/dominictarr/event-stream",
  "license": "MIT",
  "maintainers": [
    {
      "name": "dominictarr",
      "email": "dominic.tarr@gmail.com"
    }
  ],
  "name": "event-stream",
  "optionalDependencies": {},
  "readme": "# EventStream\r\n\r\n<img src=https://secure.travis-ci.org/dominictarr/event-stream.png?branch=master>\r\n\r\n[![browser status](http://ci.testling.com/dominictarr/event-stream.png)]\r\n(http://ci.testling.com/dominictarr/event-stream)\r\n\r\n[Streams](http://nodejs.org/api/stream.html \"Stream\") are node's best and most misunderstood idea, and \r\n_<em>EventStream</em>_ is a toolkit to make creating and working with streams <em>easy</em>.  \r\n\r\nNormally, streams are only used for IO,  \r\nbut in event stream we send all kinds of objects down the pipe.  \r\nIf your application's <em>input</em> and <em>output</em> are streams,  \r\nshouldn't the <em>throughput</em> be a stream too?  \r\n\r\nThe *EventStream* functions resemble the array functions,  \r\nbecause Streams are like Arrays, but laid out in time, rather than in memory.  \r\n\r\n<em>All the `event-stream` functions return instances of `Stream`</em>.\r\n\r\n`event-stream` creates \r\n[0.8 streams](https://github.com/joyent/node/blob/v0.8/doc/api/stream.markdown)\r\n, which are compatible with [0.10 streams](http://nodejs.org/api/stream.html \"Stream\").\r\n\r\n>NOTE: I shall use the term <em>\"through stream\"</em> to refer to a stream that is writable <em>and</em> readable.  \r\n\r\n### [simple example](https://github.com/dominictarr/event-stream/blob/master/examples/pretty.js):\r\n\r\n``` js\r\n\r\n//pretty.js\r\n\r\nif(!module.parent) {\r\n  var es = require('event-stream')\r\n  var inspect = require('util').inspect\r\n\r\n  process.stdin                        //connect streams together with `pipe`\r\n    .pipe(es.split())                  //split stream to break on newlines\r\n    .pipe(es.map(function (data, cb) { //turn this async function into a stream\r\n      cb(null\r\n        , inspect(JSON.parse(data)))   //render it nicely\r\n    }))\r\n    .pipe(process.stdout)              // pipe it to stdout !\r\n}\r\n```\r\nrun it ...\r\n\r\n``` bash  \r\ncurl -sS registry.npmjs.org/event-stream | node pretty.js\r\n```\r\n \r\n[node Stream documentation](http://nodejs.org/api/stream.html)\r\n\r\n## through (write?, end?)\r\n\r\nRe-emits data synchronously. Easy way to create synchronous through streams.\r\nPass in optional `write` and `end` methods. They will be called in the \r\ncontext of the stream. Use `this.pause()` and `this.resume()` to manage flow.\r\nCheck `this.paused` to see current flow state. (write always returns `!this.paused`)\r\n\r\nthis function is the basis for most of the synchronous streams in `event-stream`.\r\n\r\n``` js\r\n\r\nes.through(function write(data) {\r\n    this.emit('data', data)\r\n    //this.pause() \r\n  },\r\n  function end () { //optional\r\n    this.emit('end')\r\n  })\r\n\r\n```\r\n\r\n## map (asyncFunction)\r\n\r\nCreate a through stream from an asynchronous function.  \r\n\r\n``` js\r\nvar es = require('event-stream')\r\n\r\nes.map(function (data, callback) {\r\n  //transform data\r\n  // ...\r\n  callback(null, data)\r\n})\r\n\r\n```\r\n\r\nEach map MUST call the callback. It may callback with data, with an error or with no arguments, \r\n\r\n  * `callback()` drop this data.  \r\n    this makes the map work like `filter`,  \r\n    note:`callback(null,null)` is not the same, and will emit `null`\r\n\r\n  * `callback(null, newData)` turn data into newData\r\n    \r\n  * `callback(error)` emit an error for this item.\r\n\r\n>Note: if a callback is not called, `map` will think that it is still being processed,   \r\n>every call must be answered or the stream will not know when to end.  \r\n>\r\n>Also, if the callback is called more than once, every call but the first will be ignored.\r\n\r\n## mapSync (syncFunction)\r\n\r\nSame as `map`, but the callback is called synchronously. Based on `es.through`\r\n\r\n## split (matcher)\r\n\r\nBreak up a stream and reassemble it so that each line is a chunk. matcher may be a `String`, or a `RegExp` \r\n\r\nExample, read every line in a file ...\r\n\r\n``` js\r\nfs.createReadStream(file, {flags: 'r'})\r\n  .pipe(es.split())\r\n  .pipe(es.map(function (line, cb) {\r\n    //do something with the line \r\n    cb(null, line)\r\n  }))\r\n```\r\n\r\n`split` takes the same arguments as `string.split` except it defaults to '\\n' instead of ',', and the optional `limit` parameter is ignored.\r\n[String#split](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/split)\r\n\r\n## join (separator)\r\n\r\nCreate a through stream that emits `separator` between each chunk, just like Array#join.\r\n\r\n(for legacy reasons, if you pass a callback instead of a string, join is a synonym for `es.wait`)\r\n\r\n## merge (stream1,...,streamN) or merge (streamArray) \r\n> concat â†’ merge\r\n\r\nMerges streams into one and returns it.\r\nIncoming data will be emitted as soon it comes into - no ordering will be applied (for example: `data1 data1 data2 data1 data2` - where `data1` and `data2` is data from two streams).\r\nCounts how many streams were passed to it and emits end only when all streams emitted end.\r\n\r\n```js\r\nes.merge(\r\n  process.stdout,\r\n  process.stderr\r\n).pipe(fs.createWriteStream('output.log'));\r\n```\r\n\r\nIt can also take an Array of streams as input like this: \r\n```js\r\nes.merge([\r\n  fs.createReadStream('input1.txt'),\r\n  fs.createReadStream('input2.txt')\r\n]).pipe(fs.createWriteStream('output.log'));\r\n```\r\n\r\n## replace (from, to)\r\n\r\nReplace all occurrences of `from` with `to`. `from` may be a `String` or a `RegExp`.  \r\nWorks just like `string.split(from).join(to)`, but streaming.\r\n\r\n\r\n## parse\r\n\r\nConvenience function for parsing JSON chunks. For newline separated JSON,\r\nuse with `es.split`.  By default it logs parsing errors by `console.error`;\r\nfor another behaviour, transforms created by `es.parse({error: true})` will\r\nemit error events for exceptions thrown from `JSON.parse`, unmodified.\r\n\r\n``` js\r\nfs.createReadStream(filename)\r\n  .pipe(es.split()) //defaults to lines.\r\n  .pipe(es.parse())\r\n```\r\n\r\n## stringify\r\n\r\nconvert javascript objects into lines of text. The text will have whitespace escaped and have a `\\n` appended, so it will be compatible with `es.parse`\r\n\r\n``` js\r\nobjectStream\r\n  .pipe(es.stringify())\r\n  .pipe(fs.createWriteStream(filename))\r\n```\r\n\r\n## readable (asyncFunction) \r\n\r\ncreate a readable stream (that respects pause) from an async function.  \r\nwhile the stream is not paused,  \r\nthe function will be polled with `(count, callback)`,  \r\nand `this`  will be the readable stream.\r\n\r\n``` js\r\n\r\nes.readable(function (count, callback) {\r\n  if(streamHasEnded)\r\n    return this.emit('end')\r\n  \r\n  //...\r\n  \r\n  this.emit('data', data) //use this way to emit multiple chunks per call.\r\n      \r\n  callback() // you MUST always call the callback eventually.\r\n             // the function will not be called again until you do this.\r\n})\r\n```\r\nyou can also pass the data and the error to the callback.  \r\nyou may only call the callback once.  \r\ncalling the same callback more than once will have no effect.  \r\n\r\n## readArray (array)\r\n\r\nCreate a readable stream from an Array.\r\n\r\nJust emit each item as a data event, respecting `pause` and `resume`.\r\n\r\n``` js\r\n  var es = require('event-stream')\r\n    , reader = es.readArray([1,2,3])\r\n\r\n  reader.pipe(...)\r\n```\r\n\r\nIf you want the stream behave like a 0.10 stream you will need to wrap it using [`Readable.wrap()`](http://nodejs.org/api/stream.html#stream_readable_wrap_stream) function. Example:\r\n\r\n``` js\r\n\tvar s = new stream.Readable({objectMode: true}).wrap(es.readArray([1,2,3]));\r\n```\r\n\r\n## writeArray (callback)\r\n\r\ncreate a writeable stream from a callback,  \r\nall `data` events are stored in an array, which is passed to the callback when the stream ends.\r\n\r\n``` js\r\n  var es = require('event-stream')\r\n    , reader = es.readArray([1, 2, 3])\r\n    , writer = es.writeArray(function (err, array){\r\n      //array deepEqual [1, 2, 3]\r\n    })\r\n\r\n  reader.pipe(writer)\r\n```\r\n\r\n## pause  () \r\n\r\nA stream that buffers all chunks when paused.\r\n\r\n\r\n``` js\r\n  var ps = es.pause()\r\n  ps.pause() //buffer the stream, also do not allow 'end' \r\n  ps.resume() //allow chunks through\r\n```\r\n\r\n## duplex (writeStream, readStream)\r\n\r\nTakes a writable stream and a readable stream and makes them appear as a readable writable stream.\r\n\r\nIt is assumed that the two streams are connected to each other in some way.  \r\n\r\n(This is used by `pipeline` and `child`.)\r\n\r\n``` js\r\n  var grep = cp.exec('grep Stream')\r\n\r\n  es.duplex(grep.stdin, grep.stdout)\r\n```\r\n\r\n## child (child_process)\r\n\r\nCreate a through stream from a child process ...\r\n\r\n``` js\r\n  var cp = require('child_process')\r\n\r\n  es.child(cp.exec('grep Stream')) // a through stream\r\n\r\n```\r\n\r\n## wait (callback)\r\n\r\nwaits for stream to emit 'end'.\r\njoins chunks of a stream into a single string or buffer. \r\ntakes an optional callback, which will be passed the \r\ncomplete string/buffer when it receives the 'end' event.\r\n\r\nalso, emits a single 'data' event.\r\n\r\n``` js\r\n\r\nreadStream.pipe(es.wait(function (err, body) {\r\n  // have complete text here.\r\n}))\r\n\r\n```\r\n\r\n# Other Stream Modules\r\n\r\nThese modules are not included as a part of *EventStream* but may be\r\nuseful when working with streams.\r\n\r\n## [reduce (syncFunction, initial)](https://github.com/parshap/node-stream-reduce)\r\n\r\nLike `Array.prototype.reduce` but for streams. Given a sync reduce\r\nfunction and an initial value it will return a through stream that emits\r\na single data event with the reduced value once the input stream ends.\r\n\r\n``` js\r\nvar reduce = require(\"stream-reduce\");\r\nprocess.stdin.pipe(reduce(function(acc, data) {\r\n  return acc + data.length;\r\n}, 0)).on(\"data\", function(length) {\r\n  console.log(\"stdin size:\", length);\r\n});\r\n```\r\n",
  "readmeFilename": "readme.markdown",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/event-stream.git"
  },
  "scripts": {
    "prepublish": "npm ls && npm test",
    "test": "asynct test/",
    "test_tap": "set -e; for t in test/*.js; do node $t; done"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": {
      "ie": [
        8,
        9
      ],
      "firefox": [
        13
      ],
      "chrome": [
        20
      ],
      "safari": [
        5.1
      ],
      "opera": [
        12
      ]
    }
  },
  "version": "3.3.4"
}
